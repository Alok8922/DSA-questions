class Solution {
public:
int n,m;
 int row[4]={-1,1,0,0};
 int col[4]={0,0,-1,1};
 bool valid(int i,int j){
    return i>=0&&i<n&&j>=0&&j<m;
 }
    int minTimeToReach(vector<vector<int>>& moveTime) {
         n = moveTime.size();
        m = moveTime[0].size();

        vector<vector<int>> result(n,vector<int>(m,INT_MAX));

       
        priority_queue<
            pair<int,pair<int,int>>,
            vector<pair<int,pair<int,int>>>,
            greater<pair<int,pair<int,int>>>
        > pq;

        result[0][0]=0;
        pq.push({0,{0, 0}});

        while (!pq.empty()) {
            auto top = pq.top();
            pq.pop();

            int time = top.first;
            int i = top.second.first;
            int j = top.second.second;
                  if (i ==n-1&&j==m-1) {
                return time;
                    }

            // If already found better path, skip
            if (time > result[i][j])
             continue;

            // Explore 4 directions
            for (int k = 0; k < 4; k++) {
                int ni = i + row[k];
                int nj = j + col[k];

                if (valid(ni, nj)) {

                    // We can move only when time >= moveTime[ni][nj]
                    int newTime = max(time, moveTime[ni][nj]) + 1;

                    if (newTime < result[ni][nj]) {
                        result[ni][nj] = newTime;
                        pq.push({newTime, {ni, nj}});
                    }
                }
            }
        }

        return -1;  // If unreachable
    }
};
